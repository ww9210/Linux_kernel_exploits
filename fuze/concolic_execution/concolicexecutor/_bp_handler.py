import colorama
from pwn import *
import time
import angr


class BPHandlerMixin:
    def track_symbolic_variable(self, state):
        print 'Symbolic_Variable:', state.inspect.symbolic_name, 'size:', \
                state.inspect.symbolic_size, 'symbolic expr:', \
                state.inspect.symbolic_expr
        return

    def track_bp(self, state):
        self.debug_state(state)
        import IPython; IPython.embed()
        return


    def track_reads(self, state):
        if state.regs.rip.symbolic:  # we do not handle read when rip is symbolic
            return
        b = self.b
        sol = self.sol
        print '='*78
        print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address,\
            'Size', state.inspect.mem_read_length
        if type(state.inspect.mem_read_address) is not long:
            try:
                if self.debug_irsb:
                    irsb = b.factory.block(state.addr).vex
                    irsb.pp()
                cap = b.factory.block(state.addr).capstone
                cap.pp()
                self.dump_reg(state)
                print 'uninit:', state.inspect.mem_read_address.uninitialized,\
                    'symbolic:', state.inspect.mem_read_address.symbolic
                if state.inspect.mem_read_address.symbolic:
                    print 'read from symbolic address, primitive found!'
                    if self.pause_on_read_from_symbolic_address:
                        raw_input('wtf read from symbolic address')
                    return
                print 'checking whether memory is uninitialized...'
                t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
                if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
                    print 'memory content uninit: ', t.uninitialized,\
                        'memory content symbolic: ', t.symbolic
                    print '[+] uninitialized memory read found:', state.inspect.mem_read_address
                    print '[+] the uninitialized memory read is at:', hex(state.addr)
                    if self.resolve_uninit:
                        r = remote('127.0.0.1', self.qemu_port)
                        addr = self.sol.eval(state.inspect.mem_read_address.get_bytes(0,8),1)[0]
                        print '[+] resolving a page containing the address:', hex(addr)
                        con = self.statebroker.get_a_page(r, addr)
                        r.close()
                        if con != None:
                            self.set_concret_memory_region(state, addr, con, 4096)
                            print '[+] resolved the uninit with concrete page'
                        else:
                            print( '[!] failed to resolve the uninit memory')
                            if self.pause_on_failed_memory_resolving:
                                import IPython; IPython.embed()
                        #import IPython; IPython.embed()
                        if self.pause_on_finish_memory_loading:
                            raw_input('do the read now(continue) <-')
                else:
                    print 'Memory Content does not appear uninitialized.'
            except AttributeError as e:
                print e.args, e.message
                print('wtf track reads')
                import IPython; IPython.embed()
                pass
            except angr.errors.SimValueError as e:
                print('wtf simvalueerror')
                import IPython; IPython.embed()

        else:
            import IPython; IPython.embed()
        return

    def track_writes(self, state):
        b=self.b
        claripy = self.claripy
        print '='*78
        print 'Write', state.inspect.mem_write_expr, 'to', state.inspect.mem_write_address,\
            'size', state.inspect.mem_write_length,\
            'Write target type:', type(state.inspect.mem_write_address)
        if self.debug_irsb:
            irsb = b.factory.block(state.addr).vex
            irsb.pp()
        cap = b.factory.block(state.addr).capstone
        cap.pp()
        self.dump_reg(state)
        #if type(state.inspect.mem_write_address) not in [long, self.typebv]:
        if type(state.inspect.mem_write_address) not in [long]\
                and state.inspect.mem_write_address.symbolic:
            print 'symbolic write?'
            try:
                print 'target uninit:',state.inspect.mem_write_address.uninitialized,\
                    'target symbolic',state.inspect.mem_write_address.symbolic
                if state.inspect.mem_write_address.symbolic:
                    print '[+] write to symbolic address, primitive found!'
                    if state.addr not in self.seen_symbolic_write_primitive_addr:
                        self.seen_symbolic_write_primitive_addr.append(state.addr)
                        s=state.copy()
                        self.write_to_symbolic_address_primitive.append(\
                            {'state':s\
                            ,'timestamp':time.time()\
                            })

                    if self.pause_on_write_to_symbolic_address:
                        opt=raw_input('ipython shell? [y/n]')
                        if opt=='y\n':
                            import IPython; IPython.embed()
                if state.inspect.mem_write_address.uninitialized:
                    print 'write to uninitialized address, primitive found!'
                    if self.pause_on_uninit_write:
                        raw_input('wtf uninitialzed write')
            except AttributeError as e:
                print e.args, e.message
                print('wtf track writes')
                import IPython; IPython.embed()
                pass
            print 'end symbolic write'
        else:
            print 'normal write...'
            write_address = self.sol.eval(state.inspect.mem_write_address, 1)[0]
            if (write_address >= self.uaf_object_base)\
                    and (write_address <= self.uaf_object_base + self.uaf_object_size):
                print 'uaf_object_base', hex(self.uaf_object_base)
                print(colorama.Fore.RED + '[+] found an write_to_uaf_object primitive' + colorama.Style.RESET_ALL)
                if state.addr not in self.seen_write_to_uaf_object_primitive_addr:
                    self.seen_write_to_uaf_object_primitive_addr.append(state.addr)
                    s = state.copy()
                    new_write_to_uaf_primitive={'state': s
                            , 'in_object_offset_to_write': state.inspect.mem_write_address - self.uaf_object_base
                            , 'expr_to_write': state.inspect.mem_write_expr
                            , 'address_to_write': state.inspect.mem_write_address
                            , 'size_to_write': state.inspect.mem_write_length
                            , 'timestamp': time.time()
                            }
                    self.write_to_uaf_object_primitive.append(new_write_to_uaf_primitive)
                    # try heap meta exploit
                    self.try_heap_metadata_exploit(self.write_to_uaf_object_primitive[-1])
                if self.pause_on_write_to_uaf_object_primitive:
                    opt=raw_input('ipython shell? [y/n]')
                    if opt == 'y\n':
                        import IPython; IPython.embed()
            print 'end normal write...'
        #import IPython; IPython.embed()
        return

    def track_call_bk(self, state):
        """
        in this callback, we can not use state.addr to get current ip as it might be symbolic,
        if the rip is symbolic, we have found an exploitable primitive
        """
        print('='*78)
        print('Call instruction at:', state.inspect.function_address)
        if state.regs.rip.symbolic:  # found symbolic instruction pointer
            print(colorama.Fore.RED + '[+] control flow hijack found' + colorama.Style.RESET_ALL)
            self.add_stack_pivot_constraint(state)
            if self.pause_on_control_flow_hijack:
                opt = raw_input('ipython shell? [y/N]')
                if opt == 'y\n':
                    import IPython; IPython.embed()
        else:
            # detecting other control hijack primitives
            print 'rip', state.regs.rip
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print(colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL)
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print(colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL)
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)

        # raw_input('track_call')
        return

    def track_call(self, state):
        if not state.regs.rip.symbolic:
            print 'rip', state.regs.rip
            if self.detect_rcu_free and self.interested_funcs != {}:
                rcu_free = self.interested_funcs['kfree_call_rcu']
                if self.sol.eval(state.regs.rip,1)[0]==rcu_free and state.regs.rdi.symbolic:
                    print(colorama.Fore.RED + '[+] symbolic rcu_free found' + colorama.Style.RESET_ALL)
                    primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                    if state.history.bbl_addrs[-1] not in self.seen_control_flow_hijack_primitive:
                        self.seen_control_flow_hijack_primitive.append(state.history.bbl_addrs[-1])
                        self.control_flow_hijack_primitive.append(primitive)#add current state to CF hijack primitve

            # detecting memory leak
            if self.detect_memory_leak and len(self.memory_leak_funcs) != 0:
                for key in self.memory_leak_funcs:
                    value = self.memory_leak_funcs[key]
                    if self.sol.eval(state.regs.rip,1)[0] == value and state.regs.rax.symbolic:
                        print(colorama.Fore.RED + '[+] memory leak found' + colorama.Style.RESET_ALL)
                        primitive = {'state':state.copy(), 'timestamp':time.time(),'address':state.history.bbl_addrs[-1]}
                        if state.history.bbl_addrs[-1] not in self.seen_memory_leak_primitive:
                            self.seen_memory_leak_primitive.append(state.history.bbl_addrs[-1])
                            self.memory_leak_primitive.append(primitive)



    def address_concretization_before(self, state):
        print('=' * 5 + 'Before concretizing address' + '=' * 5)
        print 'state.addr', hex(state.addr)
        print 'Address_Concretization strategy:', \
            state.inspect.address_concretization_strategy
        print 'Address concretization action:', \
            state.inspect.address_concretization_action
        print 'address_concretization_memory:', \
            state.inspect.address_concretization_memory
        print 'address_concretization_expr:', \
            state.inspect.address_concretization_expr
        return

    def address_concretization_after(self, state):
        print('=====After address concretization=====')
        print 'address_concretization_result:', \
            state.inspect.address_concretization_result
        if state.inspect.address_concretization_action == 'load':
            print('address_concretization_action: load')
        print('=====End of concretization=====')
        if self.debug_after_address_concretization:
            opt = raw_input('ipython shell? [y/N]')
            if opt == 'y\n':
                import IPython;
                IPython.embed()

    def concretization_cond(self, state):
        return state.addr == 0xffffffff8109a62a

    def concretization_cond_15649(self, state):
        return state.addr == 0xffffffff81788a57

    def concretization_cond_0728(self, state):
        return state.addr == 0xffffffff812d86ae  # <key_revoke+30>:   mov    rax,QWORD PTR [rbx+0x80]

    def concretize_call_before(self, state):
        print('=' * 78)
        print('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy)
        print('Address_Concretization action:', \
              state.inspect.address_concretization_action)
        print('Address_Concretization memory:', \
              state.inspect.address_concretization_memory)
        print('Address_Concretization expr:', \
              state.inspect.address_concretization_expr)
        # raw_input()
        return

    def concretize_call_after(self, state):
        print('=' * 78)
        print('Address_Concretization strategy:', \
              state.inspect.address_concretization_strategy)
        print('address_concretization_result:', \
              state.inspect.address_concretization_result)
        if state.inspect.address_concretization_action == 'load':
            print ('address_concretization_action: load')
        opt = raw_input('ipython shell? [y/N]')
        if opt == 'y\n':
            import IPython;
            IPython.embed()
        return
